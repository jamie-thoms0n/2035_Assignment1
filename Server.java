/******** DO NOT EDIT THIS FILE ********/
import java.io.BufferedWriter;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;

/*
 * This file contains the main methods for the server.
 * Do NOT change anything in this file.
 * 
 * start server as:
 *      
 *      java Server <port number> <nm|wl> 
 *
 * where port number is a port for the server to listen on in the range 1025 to 65535
 * nm selects normal transfer mode 
 * wl selects transfer with lost acknowledgment 
 */

public class Server {

	static DatagramSocket ServerSocket = null;

	/* the main method  */
	public static void main(String[] args) throws IOException, InterruptedException {
		if (args.length < 2) {
			System.err.println("Usage: java Server <port number><nm|wl>");
			System.err.println("port number: is a positive number in the range 1025 to 65535");
			System.err.println("nm selects normal transfer|wl selects transfer with lost Ack");
			System.exit(1);
		} 

		Server server = new Server();
		int portNumber = Integer.parseInt(args[0]);
		String choice=args[1];

		// create a UDP socket with the entere port number
		ServerSocket = new DatagramSocket(portNumber);

		//asking the user for the loss probability when the mode is LOST_MODE - for Part 4 only
		float loss = 0;
		Scanner sc=new Scanner(System.in);   
		if (choice.equalsIgnoreCase(Protocol.LOST_MODE)) {
			System.out.println("Enter the probability of a lost ack (between 0 and 1): ");
			loss = sc.nextFloat();
		} 

		System.out.println("SERVER: Ready to receive meta data from the client "); 
		System.out.println("------------------------------------------------------------------");
		System.out.println("------------------------------------------------------------------");
		/* receive meta data from the client */
		server.ReceiveMetaData();

		System.out.println("------------------------------------------------------------------");
		System.out.println("SERVER: Waiting for the actual readings .."); 
		System.out.println("------------------------------------------------------------------");
		System.out.println("------------------------------------------------------------------");

		switch(choice)
		{
		//normal mode (ideal scenario)
		case Protocol.NORMAL_MODE:
			server.receiveNormal();
			break;

		//Lost mode (lost Ack segments)
		case Protocol.LOST_MODE:
			Protocol.instance.receiveWithAckLoss(ServerSocket,loss);
			break; 

		default:
			System.out.println("Error! mode is not recognised");  
		} 

		sc.close();
	}

	/*Receive meta data from the client */
	public void ReceiveMetaData() throws IOException, InterruptedException {
		Segment serverMetaSeg = new Segment(); 
		byte[] buf = new byte[Protocol.MAX_Segment_SIZE]; //prepare the buffer to have the max segment size

		DatagramPacket incomingPacket = new DatagramPacket(buf, buf.length);
		ServerSocket.receive(incomingPacket);
		byte[] data = incomingPacket.getData();
		ByteArrayInputStream in = new ByteArrayInputStream(data);
		ObjectInputStream is = new ObjectInputStream(in);

		// read the content of the segment
		try {
			serverMetaSeg = (Segment) is.readObject(); 
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		}  

		//if the segment is of type Meta
		if (serverMetaSeg.getType() == SegmentType.Meta) {
			//extract the number of readings, the name of the output file and the patch size
			String[] parts = serverMetaSeg.getPayLoad().split(",");
			Protocol.instance.setFileTotalReadings(Integer.parseInt(parts[0]));  
			Protocol.instance.setOutputFileName(parts[1]);
			Protocol.instance.setMaxPatchSize(Integer.parseInt(parts[2]));

			//print the expected number of segments with the other information
			System.out.println("SERVER: META [SEQ#" + serverMetaSeg.getSeqNum() + "] (Total Segments:" 
					+ (int) Math.ceil((float)Protocol.instance.getFileTotalReadings()/Protocol.instance.getMaxPatchSize()) + ", outputFile:" + Protocol.instance.getOutputFileName()  + ", patchSize:" + Protocol.instance.getMaxPatchSize() + ")");
		}
	}


	/* Receive the readings (stored in Data segments) on the given socket from the client */
	public void receiveNormal() throws IOException {
		byte[] buf = new byte[Protocol.MAX_Segment_SIZE];
		
		//creat a temporary list to store the readings
		List<String> receivedLines = new ArrayList<>();

		//track the number of the correctly received readings
		int readingCount= 0;

		// while still receiving Data segments  
		while (true) {
			DatagramPacket incomingPacket = new DatagramPacket(buf, buf.length);
			ServerSocket.receive(incomingPacket);// receive from the client    
			
			Segment serverDataSeg = new Segment(); 
			byte[] data = incomingPacket.getData();
			ByteArrayInputStream in = new ByteArrayInputStream(data);
			ObjectInputStream is = new ObjectInputStream(in);

			// read and then print the content of the segment
			try {
				serverDataSeg = (Segment) is.readObject(); 
			} catch (ClassNotFoundException e) {
				e.printStackTrace();
			}
			System.out.println("SERVER: Receive: DATA [SEQ#"+ serverDataSeg.getSeqNum()+ "]("+"size:"+serverDataSeg.getSize()+", crc: "+serverDataSeg.getChecksum()+
					", content:"  + serverDataSeg.getPayLoad()+")");

			// calculate the checksum
			long x = serverDataSeg.calculateChecksum();

			// if the calculated checksum is same as that of received checksum then send the corresponding ack
			if (serverDataSeg.getType() == SegmentType.Data && x == serverDataSeg.getChecksum()) {
				System.out.println("SERVER: Calculated checksum is " + x + "  VALID");

				// write the payload of the data segment to the temporary list 
				String[] lines = serverDataSeg.getPayLoad().split(";");
				receivedLines.add("Segment ["+ serverDataSeg.getSeqNum() + "] has "+ lines.length + " Readings");
				receivedLines.addAll(Arrays.asList(lines));
				receivedLines.add("");
				
				//update the number of correctly received readings
				readingCount += lines.length;

				// extract the client IP address and port number from the received packet for sending the ack to the client
				InetAddress iPAddress = incomingPacket.getAddress();
				int port = incomingPacket.getPort();
				//the sequence number of the Ack segment is the same as the received Data segment
				sendAck(ServerSocket, iPAddress, port, serverDataSeg.getSeqNum());
			
			// if the calculated checksum is not the same as that of received checksum, then do not send any ack
			} else if (serverDataSeg.getType() == SegmentType.Data&& x != serverDataSeg.getChecksum()) {
				System.out.println("SERVER: Calculated checksum is " + x + "  INVALID");
				System.out.println("SERVER: Not sending any ACK ");
				System.out.println("*************************** "); 
			}
			
			//if all readings are received, then write the readings to the file
			if (Protocol.instance.getOutputFileName() != null && readingCount >= Protocol.instance.getFileTotalReadings()) { 
				writeReadingsToFile(receivedLines, Protocol.instance.getOutputFileName());
				break;
			}
		}

		ServerSocket.close();
	}


	/* send the Ack segment to the client */
	public static void sendAck(DatagramSocket socket, InetAddress address, int port, int seqNum)  throws IOException {
		//create the segment
		Segment serverAckSeg =  new Segment(seqNum, SegmentType.Ack, "", "Ack".length());
		System.out.println("SERVER: Send: ACK [SEQ#" + seqNum +"]");

		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		ObjectOutputStream os = new ObjectOutputStream(outputStream);
		os.writeObject(serverAckSeg);			
		byte[] dataAck = outputStream.toByteArray();			
		DatagramPacket ackPacket = new DatagramPacket(dataAck, dataAck.length, address, port);

		// send the Ack segment 
		socket.send(ackPacket);

		System.out.println("\t\t>>>>>>> NETWORK: ACK is sent successfully <<<<<<<<<"  );
		System.out.println("------------------------------------------------" );
		System.out.println("------------------------------------------------"  );  

	}



	/* write the readings stored in the list to the output file */
	public static void writeReadingsToFile(List<String> receivedLines, String outputFileName) throws IOException {
		try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputFileName))) {
			for (String line : receivedLines) {
				writer.write(line);
				writer.newLine();
			}
		}
		System.out.println("Data written to " + outputFileName); 
	}
	
}

